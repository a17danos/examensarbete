\documentclass[swedish,template=rapport]{his}
\usepackage[style=authoryear,url=false,doi=false,isbn=false,dashed=false,
            mincitenames=3, maxbibnames=99, uniquename=init,giveninits=true,% abbreviate authors' first name
            backend=biber]{biblatex}
\usepackage[swedish]{babel}
\usepackage[parfill]{parskip}
\usepackage[tableposition=top]{caption}
\usepackage{booktabs} % for nice tables
\usepackage{soulutf8} % for hl

% Enforce to have always a lastname-comma-firstname layout
\DeclareNameAlias{sortname}{last-first}
\DeclareNameAlias{default}{last-first}

% Use ampersand as last author names separator
\AtBeginBibliography{%
  \renewcommand*{\finalnamedelim}{%
    \ifnumgreater{\value{liststop}}{2}{\finalandcomma}{}%
    \addspace\&\space}
}
\addbibresource{bibliography.bib}

% Set the parencite context specifically to use an ampersand
\DeclareDelimFormat[parencite]{finalnamedelim}{%
  \ifnumgreater{\value{liststop}}{2}{\finalandcomma}{}%
  \addspace\&\space}

\title{Benchmarking WebAssembly}
\subtitle{}
\course{IT606G - Examensarbete i informationsteknologi med inriktning mot webbprogrammering G2E, 30 hp}
\author{Daniel Oskarsson}
\timeframe{Vårterminen 2019}
\supervisor{Henrik Gustavsson}
\examiner{Mikael Berndtsson}

\begin{document}

\maketitle

\tableofcontents

\clearpage

\pagenumbering{arabic}

\section{Bakgrund}

WebAssembly\footnote{https://webassembly.org/} (Wasm) är enligt \textcite{HaasRossbergSchuffTitzerHolmanGohmanWagnerZakaiBastien2017} ett portabelt assembly-språk för webbläsare och i framtiden andra tillämpningar. Tekniskt sett är WebAssembly mellankod (eng. bytecode) som skapats genom att \emph{kompilera} (valfri form av) kod till WebAssembly \parencite{Watt2018} som sedan körs i en WebAssembly-motor, detta kan jämföras med JavaScript-kod som traditionellt sett \emph{tolkas} allt eftersom den körs i en JavaScript-motor. WebAssembly kan ses som en ersättare till tidigare tekniker som \texttt{asm.js} från Mozilla och \texttt{Native Client (NaCl)} från Google. \texttt{NaCL} kör nativ (eng. native) kod i en avgränsad del i Chrome, medan \texttt{asm.js} \parencite{Zakai2018} är en delmängd av JavaScript optimerad för prestanda \parencite{VanEsNicolayStievenartDHondtDeRoover2016} och kan köras i alla webbläsare.

Tidigare arbete kring vad som idag är WebAssembly har också resulterat i \texttt{Emscripten} \parencite{Zakai2011}, en kompilator baserad på \texttt{LLVM} \parencite{LattnerAdve2014} som ursprungligen togs fram för att kompilera JavaScript till \texttt{asm.js} \parencite{Zakai2011} men som har vidareutvecklats \parencite{HaasRossbergSchuffTitzerHolmanGohmanWagnerZakaiBastien2017} och nu kan kompilera både JavaScript och \texttt{C/C++} till både \texttt{asm.js} och WebAssembly. \texttt{Emscripten} är den vanligast förekommande kompilatorn för att kompilera WebAssembly.

WebAssembly är resultatet av gemensam forskning och utveckling mellan  Apple, Google, Microsoft och Mozilla \parencite{HaasRossbergSchuffTitzerHolmanGohmanWagnerZakaiBastien2017} och WebAssembly har därför som första teknik sedan JavaScript \emph{fullt} formellt stöd i Chrome, Edge, Firefox och Safari \parencite{Moller2018}. De webbläsare som inte stödjer WebAssembly kan enligt \textcite{HaasRossbergSchuffTitzerHolmanGohmanWagnerZakaiBastien2017} använda \texttt{asm.js}  som ''polyfill''. WebAssembly används redan idag där prestanda är av vikt, exempelvis för att generera kryptovaluta \parencite{RuthZimmermannWolsingHohlfeld2018}.

Initialt stöder WebAssembly kod skriven i \texttt{C/C++} \parencite{HaasRossbergSchuffTitzerHolmanGohmanWagnerZakaiBastien2017}. Detta fokus är till största delen ett resultat av begränsningen att WebAssembly ännu inte har stöd för automatisk minneshantering (eng. garbage collection). Enligt \textcite{HaasRossbergSchuffTitzerHolmanGohmanWagnerZakaiBastien2017} så är det ett högt prioriterat mål att från WebAssembly tillåta åtkomst till webbläsarens inbyggda minneshanterare för att på så sätt stödja språk som använder sig av automatisk minnehantering.

WebAssembly laddas in som en modul via ett JavaScript API eller en annan WebAssembly-modul \parencite{HaasRossbergSchuffTitzerHolmanGohmanWagnerZakaiBastien2017}. Det är enligt \textcite{Moller2018} \emph{inte} ett uttalat mål att WebAssembly skall ersätta JavaScript, utan tanken är att de skall \emph{komplettera} varandra. Ett exempel på hur JavaScript och WebAssembly skulle kunna komplettera varandra är att stora delar i populära JavaScript-ramverk skulle kunna bytas ut mot WebAssembly samtidigt som dess gränssnitt mot användaren av ramverket skulle kunna bibehållas helt oförändrade.

WebAssembly är en relativt ny teknik inom webbteknologi. De första artiklarna om WebAssembly publicerades 2017 \parencite{HaasRossbergSchuffTitzerHolmanGohmanWagnerZakaiBastien2017,ReiserBlaser2017}.

\clearpage

\section{Problemformulering}

Utvecklingen av webben har gett oss i tur och ordning HTML, CSS och JavaScript. JavaScript introducerades 1995 och var främst avsett att lösa små uppgifter som validering av indata och enklare animationer \parencite{Moller2018}. På senare år har webben utvecklats till att utöver vara en plattform för webbplatser även vara en plattform för (webb-)appar. Samtidigt har tillverkare av webbläsare de senaste åren fokuserat på att optimera prestanda vid körning av JavaScript på olika sätt, exempelvis genom att introducera ''Just-In-Time'' (JIT) kompilatorer \parencite{HerreraChenLavoieHendren2018}. Enligt \textcite{ReiserBlaser2017} finns det dock alltid ett önskemål om högre prestanda och \textcite{Zakai2018} beskriver JavaScript som ett hinder för krävande (eng. high-performance) appar. WebAssembly avses enligt \textcite{HaasRossbergSchuffTitzerHolmanGohmanWagnerZakaiBastien2017} vara ett alternativ till JavaScript med högre prestanda. Högre prestanda ger utrymme för mer krävande webb-appar.

Syftet är att jämföra JavaScript och WebAssembly. Frågeställningen är att avgöra om det finns en signifikant skillnad i prestanda mellan WebAssembly och JavaScript i webbläsarna Chrome, Edge, Firefox och Safari på Windows och macOS. Hypotesen är att det finns en signifikant skillnad ($\alpha = 0,01$) i prestanda mellan WebAssembly och JavaScript.

Prestanda hos WebAssembly har undersökts tidigare. \textcite{HaasRossbergSchuffTitzerHolmanGohmanWagnerZakaiBastien2017} använder \texttt{Polyhedral Benchmark suite\footnote{http://web.cs.ucla.edu/~pouchet/software/polybench/} (PolyBench/C)} för att jämföra exekveringstiden mellan nativ kod och WebAssembly. De använder sig av \texttt{Emscripten} för att generera WebAssembly och \texttt{Clang} \parencite{LattnerAdve2014} för att kompilera vanliga applikationer och jämför sedan exekveringstiden hos de två \parencite{HaasRossbergSchuffTitzerHolmanGohmanWagnerZakaiBastien2017}. \textcite{ReiserBlaser2017} använder egen JavaScript-implementation, som bedömer om ett givet tal är ett primtal eller inte, för att jämföra exekveringstiden mellan JavaScript och WebAssembly. De använder sig av en egen kompilator (\texttt{speedy.js}) för att kompilera \emph{samma} JavaScript-kod till WebAssembly och jämför sedan exekveringstiden hos WebAssembly och motsvarande JavaScript-motor.

Ingen tycks tidigare ha undersökt skillnaden i prestanda mellan WebAssembly och JavaScript med hjälp av någon av de sviter av tester som traditionellt används för att testa dagens JavaScript-motorer, exempelvis \texttt{JetStream}\footnote{https://www.browserbench.org/jetstream/}.

\clearpage

\section{Metod}

För att besvara frågeställningen kommer ett experiment i form av ett prestandajämförelse ''benchmarking'' genomföras på liknande sätt som tidigare gjorts av \textcite{HaasRossbergSchuffTitzerHolmanGohmanWagnerZakaiBastien2017}, \textcite{ReiserBlaser2017}, \textcite{,HerreraChenLavoieHendren2018} och \textcite{Zakai2018}. Enligt \textcite{WohlinRunesonHostOhlssonRegnellWesslen2012} är ett experiment lämpligt för att precist och systematiskt mäta något i en kontrollerad miljö.

Testsviten \texttt{JetStream} kommer att köras på de senaste versionerna av webbläsarna Chrome, Edge, Firefox och Safari. Resultaten kommer användas som en baslinje. \texttt{JetStream} är i grunden en pletora av tester. Flera av dem är ursprungligen skrivna i \texttt{C/C++} och kompilerade till JavaScript med \texttt{Emscripten} för att kunna inkluderas i \texttt{JetStream} och köras i webbläsare. Varje test i \texttt{JetStream} kommer kompileras till WebAssembly med \texttt{Emscripten}. De kompilerade testerna kommer publiceras på Github\footnote{http://github.com/danieloskarsson/webassembly/jetstream}. Dessa tester kommer sedan köras på samma webbläsare som motsvarande JavaScript-tester. Resultaten kommer att utvärderas statistiskt med ANOVA för att besvara frågeställningen.

Testerna kommer att köras två gånger, en gång på den senaste versionen av Windows och en gång på den senaste versionen av macOS. Eftersom Safari endast finns för macOS och Edge endast finns för Windows kommer testerna endast att köras en gång i dessa båda webbläsare.

Operativsystemen kommer att köras på samma dator där Windows kommer installeras med hjälp av BootCamp\footnote{https://support.apple.com/boot-camp}. De båda operativsystemen kommer att vara helt nyinstallerade och fått stå oanvända i 24 timmar för att testerna inte skall påverkas av indexering av filer som uppstår i samband med en nyinstallation. Samtliga tester kommer att köras med strömsladden inkopplad och datorn kommer inte vara uppkopplad till internet. 

Metoden avses vara utformad för hög intern validitet med så få bakomliggande variabler som möjligt, samt för hög extern validitet. \texttt{JetStream} är en samling av tester som plockats från andra testsviter. Testerna körs $1 000$ gånger (i rad) i syfte att ge en hög reliabilitet.

För att besvara problemformuleringen används en \emph{kvantiativ} metod som går ut på att genomföra en syntetisk prestandajämförelse. Som ett komplementt eller som ersättning till en \emph{syntetiska} prestandajämförelse skulle ett riktigt JavaScript-projekt kunna konverteras till WebAssembly och studeras. Prestandajämförelser räcker för att besvara den valda frågeställningen och dess hypotes, men är inte tillräckligt för att holistiskt beskriva skillnader mellan JavaScript och WebAssembly.  

För att beskriva fler skillnader behövs fler frågeställningar och för att få ett svar på frågeställningar som huruvida en given teknik är användbar eller på vilket sätt sätt en given teknik kan nyttjas bör \emph{kvalitatitva} metoder användas. Kvalitatitva metoder skulle kunna ge ett större perspektiv på WebAssembly och föreslås som framtida arbete.

\clearpage

\printbibliography[heading=bibintoc]

\end{document}
