Before porting selected parts of a popular framework or web app from JavaScript to WebAssembly it would be useful to know which parts to port. This thesis aims to help making such decisions by benchmarking the same code compiled to both JavaScript/asm.js and WebAssembly code. When developing a benchmarking suite it's important to be aware of how benchmarking work and try to avoid mistakes such as dead code, known data sets and shortcuts \parencite{CaiNerurkarWu1998}. According to \textcite{CaiNerurkarWu1998} tests and data should be randomly selected. The ideal benchmark suite is representativ, optimal, repeatable and uncheatable, but in practice most benchmarks are not \parencite{CaiNerurkarWu1998}.

When running a benchmarking suite it's important to be aware of what is actually measured and why. As described by \textcite{JangdaPowersGuhaBerger2019} the use of the PolyBenchC benchmark suite used by \textcite{HaasRossbergSchuffTitzerHolmanGohmanWagnerZakaiBastien2017} measures polyhedral loop optimizations which may not be representative of web apps.

